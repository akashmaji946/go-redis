{
    "DEL": {
        "usage": "DEL <key> [key ...]",
        "description": "Delete one or more keys from the database. Keys that do not exist are silently ignored and not counted. Returns an integer representing the number of keys that were actually removed. This command works with any data type (strings, lists, sets, hashes, sorted sets, HyperLogLogs). The operation is atomic and thread-safe, using a write lock to ensure consistency. Memory is freed immediately upon deletion. Changes are tracked for automatic RDB saving if configured.",
        "category": "key"
    },
    "DELETE": {
        "usage": "DELETE <key> [key ...]",
        "description": "Delete one or more keys from the database. This is an alias for the DEL command with identical behavior. Keys that do not exist are silently ignored and not counted. Returns an integer representing the number of keys that were actually removed. This command works with any data type. The operation is atomic and thread-safe.",
        "category": "key"
    },
    "EXISTS": {
        "usage": "EXISTS <key> [key ...]",
        "description": "Check if one or more keys exist in the database. Returns an integer count of how many of the specified keys exist. If the same key is specified multiple times, it will be counted multiple times if it exists. This command does not distinguish between different data types - it only checks for key existence. The operation is thread-safe and uses a read lock. Expired keys are not counted as existing.",
        "category": "key"
    },
    "EXPIRE": {
        "usage": "EXPIRE <key> <seconds>",
        "description": "Set a timeout on the specified key. After the timeout expires, the key will be automatically deleted using lazy expiration (deleted on next access). The timeout is specified in seconds as a positive integer. Returns 1 if the timeout was set successfully, or 0 if the key does not exist. The expiration is stored as an absolute timestamp internally. Use PERSIST to remove the expiration. Use TTL to check remaining time. Changes are tracked for automatic RDB saving if configured.",
        "category": "key"
    },
    "KEYS": {
        "usage": "KEYS <pattern>",
        "description": "Find all keys matching the specified glob-style pattern. The pattern supports: '*' to match any sequence of characters, '?' to match any single character, '[abc]' to match any character in the brackets, and '[^abc]' or '[!abc]' to match any character not in the brackets. Returns an array of matching key names. Returns an empty array if no keys match. Warning: This command can be slow on large databases as it scans all keys. Consider using SCAN for production environments with many keys. This operation is thread-safe and uses a read lock.",
        "category": "key"
    },
    "PERSIST": {
        "usage": "PERSIST <key>",
        "description": "Remove the expiration timeout from a key, making it persistent (never expires). Returns 1 if the timeout was successfully removed. Returns 0 if the key does not exist, if the key has already expired (and was deleted), or if the key exists but has no associated timeout. Returns an error if the wrong number of arguments is provided. This operation is the opposite of EXPIRE. Changes are tracked for automatic RDB saving if configured. This operation is thread-safe.",
        "category": "key"
    },
    "RENAME": {
        "usage": "RENAME <key> <newkey>",
        "description": "Rename a key to a new name. If the source and destination keys are the same, returns 1 without making changes. Returns 1 if the key was successfully renamed. Returns 0 if the source key does not exist, if the source key has expired, or if the destination key already exists (to prevent accidental overwrites). The operation preserves the value, type, and expiration of the original key. Memory tracking is updated to reflect the key name change. The operation is recorded to AOF if persistence is enabled. This operation is atomic and thread-safe.",
        "category": "key"
    },
    "SCAN": {
        "usage": "SCAN <cursor> [MATCH pattern] [COUNT count] [TYPE type]",
        "description": "Incrementally iterate over the keys in the database. Returns a cursor for the next iteration and an array of keys. MATCH filters keys by glob pattern. COUNT suggests the number of keys to return per iteration. TYPE filters keys by data type. This operation is thread-safe and uses a read lock.",
        "category": "key"
    },
    "TTL": {
        "usage": "TTL <key>",
        "description": "Return the remaining time to live (in seconds) of a key that has an expiration set. Returns a positive integer representing the remaining seconds until expiration. Returns -1 if the key exists but has no associated expiration (persistent key). Returns -2 if the key does not exist or has already expired (and was deleted). If the key has expired but not yet been lazily deleted, it is deleted and -2 is returned. This operation is thread-safe.",
        "category": "key"
    },
    "TYPE": {
        "usage": "TYPE <key>",
        "description": "Return the data type of the value stored at the specified key. Returns one of the following strings: 'STRING' for string values, 'LIST' for list values, 'SET' for set values, 'HASH' for hash values, 'ZSET' for sorted set values, 'HLL' for HyperLogLog values, or 'none' if the key does not exist. The type is returned in uppercase. This operation is thread-safe and uses a read lock.",
        "category": "key"
    }
}