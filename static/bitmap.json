{
    "SETBIT": {
        "usage": "SETBIT <key> <offset> <value>",
        "description": "Sets or clears the bit at the specified offset in the string value stored at key. The offset is a zero-based bit position (0 to 2^32-1). The value must be 0 or 1. If the key does not exist, a new string value is created. The string is automatically extended with zero bytes to accommodate the bit at the specified offset. Returns the original bit value that was stored at the offset (0 or 1). The bit offset is calculated from left to right (MSB to LSB within each byte). Warning: Setting a bit at a very large offset can cause significant memory allocation. This operation is O(1) and is recorded to AOF if persistence is enabled.",
        "category": "bitmap"
    },
    "GETBIT": {
        "usage": "GETBIT <key> <offset>",
        "description": "Returns the bit value at the specified offset in the string value stored at key. The offset is a zero-based bit position. When the offset is beyond the string length, or when the key does not exist, the bit is assumed to be 0. Returns 0 or 1 representing the bit value at the specified offset. The bit offset is calculated from left to right (MSB to LSB within each byte). This operation is O(1) and uses a read lock for thread safety.",
        "category": "bitmap"
    },
    "BITCOUNT": {
        "usage": "BITCOUNT <key> [start end [BYTE|BIT]]",
        "description": "Count the number of set bits (population counting) in a string. By default, all bytes in the string are examined. The optional start and end arguments specify a range to limit the counting operation. Negative values for start and end are interpreted as offsets from the end of the string. The optional BYTE or BIT modifier (Redis 7.0+) specifies whether the range indices are byte positions or bit positions (default is BYTE). Returns an integer representing the number of bits set to 1. Non-existent keys are treated as empty strings, returning 0. This operation is O(N) where N is the number of bytes examined.",
        "category": "bitmap"
    },
    "BITOP": {
        "usage": "BITOP <operation> <destkey> <key> [key ...]",
        "description": "Perform a bitwise operation between multiple source strings and store the result in the destination key. Supported operations are AND, OR, XOR, and NOT. The NOT operation takes exactly one source key. When strings have different lengths, shorter strings are treated as if they were zero-padded up to the length of the longest string. Non-existent keys are treated as empty strings. Returns an integer representing the size of the string stored in the destination key (equal to the size of the longest input string). The result overwrites any existing value at destkey. This operation is O(N) where N is the size of the longest string.",
        "category": "bitmap"
    },
    "BITPOS": {
        "usage": "BITPOS <key> <bit> [start [end [BYTE|BIT]]]",
        "description": "Return the position of the first bit set to 0 or 1 in a string. The bit argument must be 0 or 1. By default, all bytes in the string are examined. The optional start and end arguments specify a byte range to search within. Negative values are interpreted as offsets from the end. The optional BYTE or BIT modifier specifies whether start/end are byte or bit indices (default is BYTE). Returns the position as an absolute bit offset from the start of the string, or -1 if the specified bit is not found within the range. For non-existent keys, returns -1 when searching for 1, and 0 when searching for 0 (since an empty string has no 1 bits). This operation is O(N) where N is the number of bytes examined.",
        "category": "bitmap"
    },
    "BITFIELD": {
        "usage": "BITFIELD <key> [GET <encoding> <offset>] [SET <encoding> <offset> <value>] [INCRBY <encoding> <offset> <increment>] [OVERFLOW <WRAP|SAT|FAIL>]",
        "description": "Perform arbitrary bitfield integer operations on strings. This command treats a string as an array of bits and supports reading, writing, and incrementing arbitrary-width integers at any bit offset. Encoding format: 'i<bits>' for signed integers (e.g., i8, i16, i32, i64) or 'u<bits>' for unsigned integers (e.g., u8, u16, u63). Maximum is 64 bits for signed, 63 bits for unsigned. Offset format: absolute bit offset (e.g., 0, 8, 16) or '#N' for offset multiplied by encoding size (e.g., #0, #1, #2). GET returns the value at the specified position. SET stores the value and returns the old value. INCRBY increments the value and returns the new value. OVERFLOW controls behavior for INCRBY: WRAP (default) wraps around on overflow, SAT saturates at min/max values, FAIL returns nil without modifying on overflow. Returns an array with one element per GET/SET/INCRBY operation. This operation is O(1) for each subcommand.",
        "category": "bitmap"
    }
}